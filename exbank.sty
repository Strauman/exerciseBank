%% Source and documentation at https://github.com/Strauman/Handin-LaTeX
\ProvidesPackage{exbank}[2018/03/25 v0.01 Creates a setup that gives freedom in making sets and exercises.]
%!TEX root = main.tex

\@ifundefined{ownLineNoSpacesGotIt}{% \edef\warn{Compilation wont work unless \string\end{problem} and \string\end{solution} are on their own lines and without any spaces. This warning can be removed by doing \string\def\string\ownLineNoSpacesGotIt{} before \string\usepackage{exbank}}
\@latex@warning{Compilation wont work unless \string\end{problem} and \string\end{solution} are on their own lines and without any spaces. This warning can be removed by doing \string\def\string\ownLineNoSpacesGotIt{} before \string\usepackage{exbank}}
}{}
\@ifundefined{exercisesDir}{\gdef\exercisesDir{exercises}
}{}

\global\let\incl = \input
%!TEX root = main.tex
\usepackage{xstring}
\usepackage{pgffor}
\usepackage{scrextend}
\usepackage{comment}
\usepackage{calc}
%!TEX root = main.tex

\pgfkeys{/exbanki18n/.is family, /exbanki18n,
default/.style = {Problem = Problem, Solution = Solution},
Problem/.estore in = \@tr@Problem,
Solution/.estore in = \@tr@Solution
}
% %%Inside some command
\newcommand{\translateExBank}[1]{\pgfkeys{/exbanki18n, default, #1}%
}
\translateExBank{}
%
\gdef\@tr#1{\@ifundefined{@tr@#1}{#1}{\csname @tr@#1\endcsname
}
}

%!TEX root = main.tex

%% Adds macro to queue
\let\ea = \expandafter
\def\removebs#1{\if#1\@backslashchar\else#1\fi}
%% Usage: \At\BeginSomething (\BeginSomething) doesn't have to be defined
\newcommand{\At}[2]{\def\macname{\expandafter\removebs\detokenize{#1}}
\let\mname = \macname
\ifcsname At@\mname\endcsname
\ea\g@addto@macro\csname At@\mname\endcsname{#2}
\else
\ea\gdef\csname At@\mname\endcsname{#2}
\fi
}
%% Triggers queue generated by \At
%% Usage: \Trigger\BeginSomething (\BeginSomething) doesn't have to be defined
\newcommand{\Trigger}[1]{\def\macname{\expandafter\removebs\detokenize{#1}}
\let\mname = \macname
\@ifundefined{At@\mname}{}{\csname At@\mname\endcsname}
% \ifcsname At@\mname\endcsname
%   % \begingroup
%   
%   \csname At@\mname\endcsname
%   
%   % \endgroup
% \fi
}

\long\def\about#1{}
%!TEX root = main.tex

\def\ppLeading{4em}
\def\pMarginBelow{1em}
\def\pMarginAbove{1em}
\def\pMarginLeft{-1.5em}
\def\ppMargin{1em}
\def\solMargin{\dimexpr\ppMargin+\ppMargin\relax}
\def\vsSize{1em}
\def\vs{\vspace{\vsSize}}
\newcounter{problemcounter}
\setcounter{problemcounter}{0}
\newcounter{partproblemcounter}
\At\VeryBeginProblem{\stepcounter{problemcounter}
\setcounter{partproblemcounter}{1}
\vspace*{\pMarginAbove}
\begin{addmargin}{\pMarginLeft}
{\normalfont\Large\bfseries\@tr{Problem}~\theproblemcounter}
\end{addmargin}
\vspace*{\pMarginBelow}
}
\At\BeginPartproblem{\vspace{\ppMargin}%
\begin{addmargin}{\ppMargin}%
\large\hspace*{-\ppMargin}\textbf{(\theproblemcounter\alph{partproblemcounter})}\normalsize

\stepcounter{partproblemcounter}
}
\At\EndPartproblem{\hfill
\end{addmargin}\vspace*{0.5em}
}
\At\BeginSolution{\vspace*{1em}
\begin{addmargin}{\solMargin}%
\hspace*{-\solMargin}\large{\textbf{\@tr{Solution}:}}\normalsize
}
\At\EndSolution{\end{addmargin}\vspace*{1em}
}
%!TEX root = main.tex

\global\let\DisplaySolution\DisplaySolutiontrue
\gdef\isFalse{0}
\gdef\isTrue{1}
\gdef\DisplayProblem{\isTrue}
\gdef\@displayMetaCounter{\isFalse}
\gdef\ShowNumbers{\gdef\@displayMetaCounter{\isTrue}}
%%%% NB: Difference between \DisplaySolution and \DisplaySolutions
\gdef\@DisplaySolutions{\isFalse}
\gdef\DisplaySolutions{\xdef\@DisplaySolutions{\isTrue}\@latex@warning{Showing solutions}}
\AtBeginDocument{\if\@DisplaySolutions\isFalse
\@latex@warning{Hiding solutions. Show them with \string\DisplaySolutions}
\fi
}
\global\let\do@ProcessCutFile = \ProcessCutFile
%% Problems
\gdef\showhideproblem#1{%
\if\@displayMetaCounter\isTrue%
{P:\Large\themetacounter}
\Trigger\BeginPartproblem
\gdef\DisplayProblem{\isTrue}
\else
\if\DisplayProblem\isFalse
\def\ProcessCutFile{}
\else
#1
\fi
\fi
}
\generalcomment{problem}{%%%% NB: Difference between \DisplaySolution and \DisplaySolutions
\edef\DisplaySolution{\@DisplaySolutions}
%% BeginPartproblemHard is before regardless whether
%% the problem is included or not.
\Trigger\DecideProblemDisplay
\begingroup
\showhideproblem{\Trigger\BeginPartproblem}
}{\if\DisplayProblem\isFalse\else
\Trigger\EndPartproblem
\fi
\endgroup
}
%% Intro
\newenvironment{intro}{}{}
% \generalcomment{intro}{%   %% Decide wether to treat intro as problem in
%   %% include/exclude (except from \Trigger\BeginProblem ofc)
%   \if\@countIntros\isTrue
%     \Trigger\DecideProblemDisplay
%     \begingroup
%     \showhideproblem{\Trigger\BeginIntro}
%   \fi
%}{%   \if\@countIntros\isTrue
%     \Trigger\BeginIntro
%     \endgroup
%   \fi
%}
%% Solutions
\generalcomment{solution}
{\Trigger\AtBeginSolutionHard
\begingroup
\if\@DisplaySolutions\isTrue
\if\DisplayProblem\isFalse
\xdef\DisplaySolution{\isFalse}
\fi
\fi
% \inspw{\DisplaySolution}
\if\DisplaySolution\isTrue
\Trigger\BeginSolution
\else
\def\ProcessCutFile{}
% \begingroup
% \edef\tmp{\def\noexpand\CommentCutFile{answer.tex}}
% \tmp
% \def\ProcessCutFile{\do@ProcessCutFile}
\fi
}{% \input{\CommentCutFile}
\if\DisplaySolution\isTrue
\Trigger\EndSolution
\fi
\Trigger\EndSolutionHard
\endgroup
}
%% Problem introductions
% \isin:
% #1: haystack
% #2: needle
% #3: action if found in list
% #4: action if not found in list
\gdef\isin#1#2#3#4{\def\needle{#2}
\def\haystack{#1}
\def\isFalse{0}
\let\isInList = \isFalse
\IfInteger{\haystack}{\if\haystack\needle
#3
\else
#4
\fi
}{\foreach\pp in #1{\if\pp\needle
\gdef\isInList{1}
#3
\fi
}
\if\isInList\isFalse
#4
\fi
}
}
%!TEX root = main.tex
\let\ea = \expandafter
\newcounter{metacounter}
\def\emptyList{-1}
\begingroup\lccode`\|=`\\
\lowercase{\endgroup\def\removebs#1{\if#1|\else#1\fi}}
\newcommand{\macroname}[1]{\expandafter\removebs\string#1}
\gdef\ifppMode#1{\def\mname{\macroname{#1}}
\if\mname\ppMode
}
\gdef\isppMode#1#2{\edef\mname{\macroname{#1}}
\if{\macroname{#1}}\ppMode#2\fi
}
\gdef\@noneofone#1{}
\gdef\@noneOfTwo#1#2{}
%%% NOT WORKING
\gdef\@ifppMode#1{%
% \edef\mname{\macroname{#1}}
\ifnum\pdfstrcmp{\macroname{#1}}{\ppMode}=\z@%
\expandafter\@firstofone%
\else%
\expandafter\@noneofone%
\fi%
}%
\def\pm@Exclude{exclude}
\def\pm@Select{select}
%% Deciding whether problem (and accompanied solution) should be shown
\let\ipm\@ifppMode
\let\T\isTrue
\let\F\isFalse
\At\DecideProblemDisplay{\if\ppList\emptyList
\xdef\DisplayProblem{\ipm\exclude\T\ipm\select\F}
\else
\isin{\ppList}{\themetacounter}{\xdef\DisplayProblem{\ipm\exclude\F\ipm\select\T\ipm\normal\T}
}{\xdef\DisplayProblem{\ipm\exclude\T\ipm\select\F\ipm\normal\T}
}
\fi
\inspw\DisplayProblem
\stepcounter{metacounter}
}
%% Generates sets that can be iterated over
\gdef\makeset#1#2{\ea\gdef\csname setlist@#1\endcsname{#2}
}
%% Sets the variables \ppList and \exerciseFile based on the current set
\newcommand{\redef}[3][{-1}]{\gdef\ppList{#1}
\gdef\exerciseFile{#2}
\gdef\ppMode{#3}
}
%% Converts {A}{1,2,3} into [{1,2,3}]{A}{exclude} such that it can be sent
%% as optional arguments to redef. The last is set as ppMode (exclude/select/mix)
\newcommand{\exclude}[2]{[{#2}]{#1}{exclude}}
\newcommand{\select}[2]{[{#2}]{#1}{select}}
%% Build one exercise
\gdef\buildex#1{\makeset{#1}{#1}
\buildset{#1}
}
%%Logic for building a set
\gdef\@countIntros{\isFalse}
\newcommand\buildset[2][]{\def\moarg{#1}
\def\argToShowIntro{intro}
\ifx\moarg\argToShowIntro%
\gdef\@countIntros{\isTrue}
\@latex@warning{Counting intros!}
\fi
%% Setting the global setName
\xdef\setName{#2}
%% Warnins if the set doesn't exist
\@ifundefined{setlist@#2}{\@latex@error{Couldn't find set #2. Did you remember to do \string\makeset{#2}{}?}
\stop
}{}
%% Sets the current setlist from the variable
%% generated in makeset
\edef\setlist{\csname setlist@#2\endcsname}
\Trigger\StartBuildset
%% Loop through list
\foreach\exerciseFileInfo in \setlist{%% ppList is -1 if it's not a list
\gdef\ppList{-1}
%% Counter used for iterating over partproblems
%% (Cant' use partproblemcounter since some of them might be excluded)
\setcounter{metacounter}{1}
%% Checking whether we have optional args
%% I.e. one of the arguments are sent via \exclude
%% And then send it to \redef
\StrLeft{\exerciseFileInfo}{1}[\firstchar]%
\if[\firstchar
\ea\redef\exerciseFileInfo\relax
\else
\redef{\exerciseFileInfo}{normal}
\fi
%% TRIGGER EVERTYHING
\Trigger\InputExercise
\Trigger\BeginProblem
%% The two above are meant to be aliases
%% The one below \VeryBeginProblem is only for stuff that
%% is intended to be a part of the problem
%% e.g. problem header is using this.
\Trigger\VeryBeginProblem
%% \incl = \input because otherwise latexpanded would try.
%% to input the file
\incl{\exercisesDir/\exerciseFile}
%% More triggers
\Trigger\EndProblem
\Trigger\EndInputExercise
}
\Trigger\EndBuildset
}
%!TEX root = ../main.tex
%% Reference problems
\newcommand\refcounter[1]{\edef\@currentlabel{#1}%
}
\DeclareRobustCommand{\pplabel}[1]{\refcounter{\theproblemcounter}\label{pr:\exerciseFile:#1}
\refcounter{\thepartproblemcounter}\label{pp:\exerciseFile:#1}
}
\let\pptag = \pplabel
\newcommand\pppref[1]{%
(\ref{pp:\exerciseFile:#1})\relax%
}
\newcommand\ppref[1]{%
\ref{pr:\exerciseFile:#1}\ref{pp:\exerciseFile:#1}\relax%
}
\newcommand\pref[1]{%
\ref{pr:\exerciseFile:#1}\relax%
}

